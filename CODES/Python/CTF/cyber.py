from Cryptodome.Util.number import long_to_bytes, inverse

# Public key values (from your problem)
q = 118782806870790459877276946144534340459070276298147139413034770491543505960286655401975985304720134389194848276366937767931814930100040579383431258523071322802488365288182549512083935086200116831560554704160682669413672809274976929538511753754624910540004274848919618576618469494826512960106161782121150998263
h = 25473748602172716217323377502293735360476598685950701141218238675886715542712499286192289401073765275784785679678342729251134933091712208422172373546295458497851984370522852288928100340491754417322895436201334085906926323804660279481651724780922432451616022829468200469083544530000782893494326532297173802238

# Ciphertext
e = 34963993283511293547063333294941000231429209341161023652037537757573244023372392985066441803391679270951631633606004819272904762713143945564988378517025552064134260354064796308229964189369070891208089310672819068205082794924269757716840764888524756585160076900371457337288547081546893438482082138367328168427

# Private key components (replace these with actual private keys)
# If you don't have these, you cannot decrypt.
f = 1234567890123456789012345678901234567890  # placeholder! Replace with real f
g = 9876543210987654321098765432109876543210  # placeholder! Replace with real g

# Decrypt function (as per your scheme)
def decrypt(q, f, g, e):
    # Calculate (f * e) mod q
    a = (f * e) % q

    # Compute inverse of f modulo g
    inv_f_mod_g = inverse(f, g)

    # Recover m
    m = (a * inv_f_mod_g) % g
    return m

try:
    m = decrypt(q, f, g, e)
    print(f"Recovered integer m: {m}")

    # Convert back to bytes (flag)
    flag_bytes = long_to_bytes(m)

    # Print the flag as string (decode carefully)
    print("Recovered flag:", flag_bytes.decode(errors='ignore'))

except Exception as ex:
    print("Error during decryption:", ex)
